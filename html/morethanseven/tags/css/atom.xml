<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: css | Morethanseven]]></title>
  <link href="http://www.morethanseven.net/tags/css/atom.xml" rel="self"/>
  <link href="http://www.morethanseven.net/"/>
  <updated>2014-03-15T23:32:30+00:00</updated>
  <id>http://www.morethanseven.net/</id>
  <author>
    <name><![CDATA[Gareth Rushgrove]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Less CSS]]></title>
    <link href="http://www.morethanseven.net/2009/06/17/less-css/"/>
    <updated>2009-06-17T00:00:00+01:00</updated>
    <id>http://www.morethanseven.net/2009/06/17/less-css</id>
    <content type="html"><![CDATA[<p>Ruby people <em>really</em> don't like CSS do they? But "Less":http://lesscss.org/ is actually pretty cool. It's basically an attempt to bootstrap features, specifically Variables, Mixins, Operations and Nested Rules, into CSS. The best part about this is it uses CSS syntax and a simple one step compiler. I'd be interested to know what the folks at the W3C think about this.</p>

<p>So for instance you can do:</p>

<p>pre. /<em> LESS </em>/
@brand_color: #4D926F;</p>

<h1>header {</h1>

<p>  color: @brand_color;
}
h2 {
  color: @brand_color;
}</p>

<p>and compile it down to:</p>

<p>pre. /<em> CSS </em>/</p>

<h1>header {</h1>

<p>  color: #4D926F;
}
h2 {
  color: #4D926F;
}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Universal Internet Explorer 6 CSS and different types of sites]]></title>
    <link href="http://www.morethanseven.net/2009/05/21/universal-ie6-css-and-different-types-of-sites/"/>
    <updated>2009-05-21T00:00:00+01:00</updated>
    <id>http://www.morethanseven.net/2009/05/21/universal-ie6-css-and-different-types-of-sites</id>
    <content type="html"><![CDATA[<p>Andy Clarke, as only he can, has started something of a slagging match with his proposals for a "single, central IE6 stylesheet":http://forabeautifulweb.com/blog/about/universal_internet_explorer_6_css/. My first impression was that this is basically a much better version of the browser defaults.</p>

<p>Between backslapping and shouts of heresy there are a few good comments floating on the post so far (I'd expect more). But most of them seem to assume only two types of website exist:</p>

<h1>Websites for <em>clients</em>. You know, business to business or business to consumer sorts of things. Online stores, radio station websites, newspapers, company brochures, etc.</h1>

<h1>Personal blogs</h1>

<p>Obviously that covers only a fraction of web pages, but it covers a much larger proportion of web sites. What do I mean by that?</p>

<h1>Admin interfaces. Available all over the place and often used by a very small number of people.</h1>

<h1>Intranets. If your company default browser isn't IE6 then don't spend more time that you have to supporting it.</h1>

<h1>Internal application interfaces. Everything from holiday to payroll to IT helpdesk requests are often built as well apps. Again if the audience using them isn't using IE6 then don't waste you're time.</h1>

<p>Most people (ok so this might be my opinion) seem to work within small to medium sized agency style places. Smallish companies need to rely more on employees as part of their marketing effort, younger people tend to be more militant and people working for smaller organisations (like Andy) tend to benefit more from a little celebrity. But that ignores an army of people who work in house or in other types of company that just happen to build top notch web sites or applications. I've now worked in everything from small agencies, via medium sized agencies to freelance and inhouse. They are all different and all place different types of time pressure on the people involved.</p>

<p>Another argument to be had here is summed up by Sion ("http://twitter.com/sionnnn/status/1872141409":http://twitter.com/sionnnn/status/1872141409)</p>

<p>bq. if u write code with all browsers in mind from the offset it doesn't take any longer though? hows that commercially unsound?</p>

<p>And this is pretty much how I used to work. But this means ignoring whole swathes of the unsupported parts of CSS2 and in particular CSS3. CSS3 doesn't really allow you to make designs that you couldn't make before (ok, that's a little unfair, maybe) but it does allow you to do what you did before <em>much more efficiently</em>. Multi-column layout stuff, multiple background, rounded corners, opacity, RGBa. Smaller stylesheets are easier and quicker to write, test and maintain. And sometimes the time saved is worth more than the additional overhead of writing and maintaining CSS for IE6. Maybe not for a decent sized consumer project with a reasonable team and a few hundred thousand budget. Maybe not for a local council or government site. But for a surprisingly large range of other types of projects this might be a worthwhile approach.</p>

<p>Something else I think that comes through in many of the comments is that it's often seen as the web designers job to fight for things. So we fight to ensure time is spend on making something accessible. We fight to make sure we use valid code wherever possible. We fight for sensible fallbacks when javascript isn't available. But we also get accused of not being able to see both sides and at times being unrealistic. Worth considering with regards peoples initial reactions to this, mine included.</p>

<p>The only thing I would say to anyone looking to use this is don't create your own version. Use the "one from google code":http://code.google.com/p/universal-ie6-css/. As Andy suggests, do suggest improvements, ideally by making the changes yourself presumably along with a solid test case. The time saving benefits basically disappear if we all have to maintain our own versions, before that means we have to test our own versions.</p>

<p>I'm not saying <em>ignore IE6</em>, and neither is Andy (I don't think). I'm saying pick your battles. I've build websites to support everything under the sun. Sometimes it's been absolutely the right thing to do, sometimes in hindsight it's probably been a little bit of wasted time. I'm sure you can think of similar times from the sites you've been involved in.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS Test on GitHub]]></title>
    <link href="http://www.morethanseven.net/2008/11/22/css-test-github/"/>
    <updated>2008-11-22T00:00:00+00:00</updated>
    <id>http://www.morethanseven.net/2008/11/22/css-test-github</id>
    <content type="html"><![CDATA[<p>I upload the "work I've done so far":http://github.com/garethr/css-test/tree/master on testing CSS. It's still work in progress obviously but if you're interested do let me know. I've stared with the image approach but will hopefully have something up demonstrating the selenium/rendered DOM position approach as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSSDoc]]></title>
    <link href="http://www.morethanseven.net/2008/11/11/cssdoc/"/>
    <updated>2008-11-11T00:00:00+00:00</updated>
    <id>http://www.morethanseven.net/2008/11/11/cssdoc</id>
    <content type="html"><![CDATA[<p>"CSSDOC":http://cssdoc.net/ looks like a good idea. I'm sure a few people mentioned this last year at @media after the talk by the people from The Guardian but nothing came from it. Hopefully tools will start to come about soon.</p>

<p>bq. CSSDOC is a convention to comment Cascading Style Sheets (CSS) to help individuals and teams to improve writing/coding/styling/managing CSS files. It is an adoption of the well known JavaDoc / DocBlock based way of commenting source-code. That's putting style, docblocks and tags together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing CSS - Looking for a Solution]]></title>
    <link href="http://www.morethanseven.net/2008/10/13/unit-testing-css-looking-solution/"/>
    <updated>2008-10-13T00:00:00+01:00</updated>
    <id>http://www.morethanseven.net/2008/10/13/unit-testing-css-looking-solution</id>
    <content type="html"><![CDATA[<p>bq. I think it's an epic failure of web standards that CSS is the only essentially untestable technology invented in last decade - "Tomasz":http://twitter.com/t_a_w/statuses/957359524</p>

<p>Talking today on Twitter with "Tomasz":http://twitter.com/t_a_w got me thinking again about one of those problems that I come back to once in a while. Unit testing CSS. CSS development is a pain, even with some sort of "system":http://natbat.net/2008/Sep/28/css-systems/. Admit it. I actually like CSS most of the time but it's still painful at times. Hopefully with that out of the way you feel better.</p>

<p>bq. unit testing is a method of testing that verifies the individual units of source code are working properly. A unit is the smallest testable part of an application.</p>

<p>All testing past simple validation of CSS seems to be done visually at present.
Thinking about this from the point of view of CSS seems straight forward, but turns out not to be so for a variety of reasons. The problem lies in the cascading and compounding nature of the beast. Each individual CSS rule might do something which is self contained, but the chances on a real site are probably slim. For instance:</p>

<p>pre. body {
   font-size: 100%;
}
p {
   font-size: 2em;
}</p>

<p>What is the size of the font size of a paragraph? It turns out it depends. Not just on more than one unit of source code (we have two rules here) but also on things like the browser. And how do we get this font size from a browser in the first place? I generally dislike "Selenium":http://selenium.openqa.org/ but does it provide a mechanism for getting at the calculated DOM attribute values? Do we have to interface directly with a browser at a lower level?</p>

<p>"wxMozilla":http://wxmozilla.sourceforge.net/, "wxWebKit":http://wxmozilla.sourceforge.net/ or maybe "pywebkitgtz":http://code.google.com/p/pywebkitgtk/ might prove useful, but I'm not sure at what level they operate. What I'm imagining here is maybe something like (excuse the Python, hopefully you get the idea):</p>

<p>pre. def test_text_size_is_12px(self):</p>

<pre><code>response = fetch_with_browser('http://www.google.com')
self.assertEquals(12, response.search("p").fontSize    
</code></pre>

<p>So we could use CSS selectors (ie. <em>p</em>) to find elements and then assert various DOM properties (ie. <em>fontSize</em>) are equal to values we specify. The magic is in getting access to those calculated DOM attribute values from an actual browser engine.</p>

<p>Another approach would seem to be looking at visual rendering and comparing against a known good version. This seems to be something that the "Mozilla folks got up to a while back":http://weblogs.mozillazine.org/roc/archives/2005/03/visual_regressi.html to test different browser versions. Their are a few tools that might help us out here too; "BrowserCam":http://www.browsercam.com/ provides a paid for service, "Webkit2png":http://www.paulhammond.org/webkit2png/ is a handy command line script I've had fun with in the past and "IECapt":http://iecapt.sourceforge.net/ appears to be a similar beast for Internet Explorer. "CutyCapt":http://cutycapt.sourceforge.net/ is another cross platform webkit based utility. I can see a few gotchas lurking here. Animations or slow loading javascript would obviously throw this into disarray. But disabling these in the browser might get up somewhere. How to compare images  produced I'm not yet sure, but I reasons someone reading this might have a good idea?</p>

<p>As the title would suggest this post does not contain the answer, only a few useful links and two possible approaches to the problem. The questions at this stage are:</p>

<ul>
<li>Does any of this exist already? If so who do we need to cuddle up to to get access to it?</li>
<li>Are any of the technical hurdles to either of the approaches mentioned above insurmountable? If not what is the best solution?</li>
<li>Does anyone except me and Tomasz even want this?</li>
</ul>


<p>I reason their are a fair few things that would be needed to make this first practical and later standard; nice APIs, run times in various languages, and working out whether or not it actually helps CSS development to name but a few. But right now I'd go for a limited proof of concept that works on my machine. If anyone has any links to thinks that might be good starting points please let me know. Other ideas welcome as well.</p>

<p>One last thing; "Mozilla's latest employees":http://ajaxian.com/archives/ajaxians-join-mozilla-creating-developer-tools are looking at the whole spectrum of developer tools. I'd love for them to start with something like this.</p>
]]></content>
  </entry>
  
</feed>
